<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分数规划选讲</title>
    <url>/2019/11/24/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92%E9%80%89%E8%AE%B2/</url>
    <content><![CDATA[<p>问就是鸽了</p>
]]></content>
      <categories>
        <category>分数规划</category>
      </categories>
  </entry>
  <entry>
    <title>Meissel-Lehmer算法</title>
    <url>/2020/04/27/Meissel-Lehmer%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>首先引入一个问题。LibreOJ 6235：令 $\pi(n)$ 为 $n$ 以内的质数个数，求 $\pi(n)$ $(1 \leq n \leq 10^{11})$。</p>
<p>当然你可能会说你有分段打表的做法。众所周知，$1 \leq l \leq r \leq 10^{12}$ 且 $0 \leq r - l \leq 10^6$ 时，$[l, r]$ 中质数个数有一个很 trivial 的类似 Eratosthenes 筛的 $O((r - l)\log \log  \sqrt r)$ 的做法。在这个基础上把 $[1, 10^{11}]$ 分成 $10^4$ 段，每段在本地预处理一下，段外的部分再单独算。这样分段打表确实可以卡过去，但是我们有不那么生草的做法：<del>洲阁筛</del> <del>min_25筛</del> Meissel-Lehmer 算法可以在 $O(n^{\frac23})$ 的时间复杂度内计算 $\pi(n)$。</p>
<p>这个算法在算法竞赛选手之间并不怎么普及（所以想写这篇文章），可能是因为实现起来确实略微有点麻烦（尤其是对不能抄板子的 OI 选手来说？）。虽然说 Miller-Rabin 素性判断和 Pollard-Rho 质因数分解也很麻烦，但也面对的场景大概也多一些，相比之下 Meissel-Lehmer 算法在算法竞赛生涯中可能遇不到几次（？）。目前见到的相关题目只有 2016 ICPC 沈阳赛区网络赛 J 和 2020 毛营 Day5 I，更生草的是可以看到后者的官方题解就是分段打表……大概进一步印证了这个算法的冷门……？</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>令 $p_1, p_2, \dots, p_m$ 为前 $m$ 个质数。定义 $\phi(n, m)$ 为 $[1, n]$ 内所有质因子都大于 $p_m$ 的数的个数，$P_k(n, m)$ 为 $[1, n]$ 内恰有 $k$ 个大于 $p_m$ 的质因子的数的个数。 特别地，令 $P_0(n, m) = 1$，则有</p>
<script type="math/tex; mode=display">
\phi(n, m) = P_0(n, m) + P_1(n, m) + \dots + P_k(n, m) + \dots</script><p>注意到 $p_m^k &gt; n$ 时有 $P_k(n, m) = 0$，所以，如果我们取 $x \in [n^{\frac13}, n^{\frac12}]$ 并令 $m = \pi(x)$，对于任意 $k \geq 3$，都有 $P_k(n, m) = 0$。即，</p>
<script type="math/tex; mode=display">
\phi(n, m) = P_0(n, m) + P_1(n, m) + P_2(n, m)</script><p>根据定义，显然 $P_1(n, m) = \pi(n) - m$，于是我们对上式适当变换，得</p>
<script type="math/tex; mode=display">
\pi(n) = \phi(n, m) - P_2(n, m) + m - 1</script><p>接下来，我们只需要计算 $\phi(n, m)$ 和 $P_2(n, m)$。根据定义，不难得到其计算方式如下：</p>
<script type="math/tex; mode=display">
P_2(n, m) = \sum_{x < p \leq \sqrt n} (\pi(\frac np) - \pi(p) + 1) \\
\begin{eqnarray}
\phi(n, m) =
\begin{cases}
[n]                                          & m = 0    \\
\phi(n, m - 1) - \phi(\frac {n}{p_m}, m - 1) & m \geq 1
\end{cases}
\end{eqnarray}</script><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="P-2-n-m"><a href="#P-2-n-m" class="headerlink" title="$P_2(n, m)$"></a>$P_2(n, m)$</h3><p>对于 $x &lt; p \leq \sqrt n$，显然有 $\frac np &lt; \frac nx &lt; n^{\frac 23}$，为了快速计算 $P_2(n, m)$，我们可以用线性筛 $O(n^\frac 23)$ 预处理 $[1, n^{\frac 23}]$ 内的质数，然后 $O(n^\frac 12)$ 进行累加。时间复杂度 $O(n^\frac 23)$，空间复杂度 $O(n^\frac 23)$。</p>
<p>如果这个空间复杂度无法接受，我们可以时间换空间，少预处理一些，对于较大的询问则令 $\pi(n)$ 和 $P_2(n, m)$ 相互调用。那么时空复杂度是多少，究竟应该预处理多少呢？下面那份网上找的板子预处理的范围是 $5 \times 10^6$，并且认为可以降到 $n^\frac 13$，我暂且没算明白……</p>
<h3 id="phi-n-m"><a href="#phi-n-m" class="headerlink" title="$\phi(n, m)$"></a>$\phi(n, m)$</h3><p>更算不明白了……这式子看上去挺慢的，然而又可以大力预处理大力剪枝（见板子），总之实际跑起来完全没问题。但很想知道时间复杂度怎么算……</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这是网上可以大量找到的一个 Meissel-Lehmer 的板子（看码风也知道不是我写的），想自己整一个，但是我太懒了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span> + <span class="number">2</span>;<span class="comment">//通过知道前面的n^1/3的质数可以推断后面n^2/3的质数所以可以适当减小</span></span><br><span class="line"><span class="keyword">bool</span> np[N];</span><br><span class="line"><span class="keyword">int</span> prime[N], pi[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    np[<span class="number">0</span>] = np[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    pi[<span class="number">0</span>] = pi[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) prime[++cnt] = i;</span><br><span class="line">        pi[i] = cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            np[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)   <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;<span class="comment">//为了减小内存可以不过是质数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">11</span> * <span class="number">13</span> * <span class="number">17</span>;<span class="comment">//为了减小内存可以不过要按质数减小如去掉17</span></span><br><span class="line"><span class="keyword">int</span> phi[PM + <span class="number">1</span>][M + <span class="number">1</span>], sz[M + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getprime();</span><br><span class="line">    sz[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= PM; ++i)  phi[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sz[i] = prime[i] * sz[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= PM; ++j) phi[j][i] = phi[j][i - <span class="number">1</span>] - phi[j / prime[i]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt2</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll r = (ll)<span class="built_in">sqrt</span>(x - <span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">while</span>(r * r &lt;= x)   ++r;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt3</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll r = (ll)cbrt(x - <span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">while</span>(r * r * r &lt;= x)   ++r;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getphi</span><span class="params">(ll x, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= M)  <span class="keyword">return</span> phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= prime[s]*prime[s])   <span class="keyword">return</span> pi[x] - s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= prime[s]*prime[s]*prime[s] &amp;&amp; x &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[sqrt2(x)];</span><br><span class="line">        ll ans = pi[x] - (s2x + s - <span class="number">2</span>) * (s2x - s + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt;= s2x; ++i) ans += pi[x / prime[i]];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getphi(x, s - <span class="number">1</span>) - getphi(x / prime[s], s - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getpi</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N)   <span class="keyword">return</span> pi[x];</span><br><span class="line">    ll ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pi[sqrt3(x)] + <span class="number">1</span>, ed = pi[sqrt2(x)]; i &lt;= ed; ++i) ans -= getpi(x / prime[i]) - i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lehmer_pi</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N)   <span class="keyword">return</span> pi[x];</span><br><span class="line">    <span class="keyword">int</span> a = (<span class="keyword">int</span>)lehmer_pi(sqrt2(sqrt2(x)));</span><br><span class="line">    <span class="keyword">int</span> b = (<span class="keyword">int</span>)lehmer_pi(sqrt2(x));</span><br><span class="line">    <span class="keyword">int</span> c = (<span class="keyword">int</span>)lehmer_pi(sqrt3(x));</span><br><span class="line">    ll sum = getphi(x, a) +(ll)(b + a - <span class="number">2</span>) * (b - a + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a + <span class="number">1</span>; i &lt;= b; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll w = x / prime[i];</span><br><span class="line">        sum -= lehmer_pi(w);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; c) <span class="keyword">continue</span>;</span><br><span class="line">        ll lim = lehmer_pi(sqrt2(w));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= lim; j++) sum -= lehmer_pi(w / prime[j]) - (j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个板子有一个比较有疑问的地方：有两个功能完全一样的函数 <code>getpi</code> 和 <code>lehmer_pi</code>。很显然 <code>getpi</code> 就是我们上面介绍的方法，但 <code>lehmer_pi</code> 写的内容我完全没懂……看起来是传说中（？）Deleglise 和 Rivat 提出的 $O(\frac{n^\frac 23}{\log^2 n})$ 的优化（有兴趣可以看<a href="https://www.ams.org/journals/mcom/1996-65-213/S0025-5718-96-00674-6/S0025-5718-96-00674-6.pdf" target="_blank" rel="noopener">这篇论文</a>）。如果真的是的话，只能说这个优化的常数也太大了——测试了各种数据范围，结论是这个 <code>lehmer_pi</code> 跑起来比 <code>getpi</code> 还要慢一些……如果要抄这个板子的话，还是直接忽略最后一段吧……</p>
]]></content>
      <categories>
        <category>数论</category>
        <category>整除与同余</category>
      </categories>
  </entry>
  <entry>
    <title>[20200426] 2020 Petrozavodsk Winter Camp Day 5</title>
    <url>/2020/05/01/20200426-2020-Petrozavodsk-Winter-Camp-Day-5/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/profile/triple__a" target="_blank" rel="noopener">triple_a</a> 问我和 <a href="https://codeforces.com/profile/nezzar" target="_blank" rel="noopener">clp012345</a> 要不要来玩，于是我就打了（前 World Finalist 带飞谁不爱呢）。</p>
<p>因为纯属娱乐所以可能并不是全力打，不过也并没有做到同一时刻只有一个人写……总之就是图一乐吧。</p>
<p>刚开场的时候因为是娱乐所以他们两个也就随便开题不跟榜了，我们各自读了一下几道题。clp012345 开始猛凹 C 凹了接近两个小时（结果是 C 最后也没过）。我看到有人过 L 就大力 WA 了一发，发现把大于写成大于等于，<strong>43min2A</strong>。B 题 triple_a 说只会 TLE 的枚举子集，于是 clp012345 说 Sum over Submask DP 能做，<strong>51min1A</strong>。triple_a 又读了 I 题，说做法显然但是难写，我一看题居然是原题（2016 CCPC Changchun J），可能毛子出题人没看过国内这场，于是直接复制粘贴交了，<strong>71min1A</strong>。G 我之前就说是大力枚举，但我不会计算几何，让 triple_a 写了，<strong>105min2A</strong>。我们交流了一下 F 的题意，然后 triple_a 觉得他大概会写，然后他说反正是随便打打所以他有事要出门了（草）。我大力猜了一下 A 题有个结论，但是需要筛 $10^{11}$ 以内的质数个数，时间复杂度没法接受，clp012345 告诉我有一种叫作 <a href="https://tanakarino.cn/2020/04/27/Meissel-Lehmer算法/" target="_blank" rel="noopener">Meissel-Lehmer</a> 的神棍算法可以 $O(n^\frac 23)$ 求这个东西……找了个板子复制粘贴（？），然后我搞错边界，又贡献一发罚时，<strong>156min2A</strong>。期间 clp012345 单切了 H（我题都没读……），<strong>167min2A</strong>。 接下来我假装看 C 和 E，其实已经没思路了完全躺了（？）。但他们两个还是很猛，clp012345 单切了 J，<strong>230min4A</strong>。triple_a 回来把 F 写了，<strong>257min2A</strong>。我跟 clp012345 说 E 题的圆其实就是竖线，他说用离散化线段树维护一下就行，<strong>293min4A</strong>。</p>
<p>前 World Finalist 带飞果然牛逼，9 个题，力压 dmy（？），我全程躺着被带飞。</p>
<h1 id="部分题解（待完善）"><a href="#部分题解（待完善）" class="headerlink" title="部分题解（待完善）"></a>部分题解（待完善）</h1><h2 id="Problem-A-Bags-of-Candies"><a href="#Problem-A-Bags-of-Candies" class="headerlink" title="Problem A. Bags of Candies"></a>Problem A. Bags of Candies</h2><p>大致题意：把 $A = \{1,2,\dots,n\}$ 分成尽可能多对，使得每一对的两个数都不互质，问最大可能的对数。有 $z$ 组测试数据。</p>
<p>$1 \leq z \leq 5$</p>
<p>$2 \leq n \leq 10^{11}$</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>半场的时候动这个题的队伍只有个位数。可能大家都觉得有别的题可做，不像我别的都不会就来瞎猜结论了。结论就是，将 $1$ 和大于 $\frac n2$ 的质数从 $A$ 里删掉，剩下的集合 $A’$ 一定是可以匹配满的，所以答案就是 $\frac {|A’|}2$。</p>
<p>赛中是猜的，这里给一个简单证明。</p>
<p>将 $A’$ 的所有元素按最大质因子 $d$ 分组，那么每组都可以表示成 $A_d = \{d,2d,\dots,\lfloor \frac nd \rfloor d\}$ 的形式（注意并不一定 $|A_d|=\lfloor \frac nd \rfloor$，比如 $77 \notin A_7$），显然组内的数都是不互质的。</p>
<p>如果 $|A_d|$ 是偶数，直接令组内的数任意两两配对；如果 $|A_d|$ 是奇数，则除了 $2d$ 以外任意两两配对。所有组都作完以上匹配之后，剩下的数都是 $2$ 的倍数，所以也都不互质，也可以任意两两配对。最后剩下的数显然至多只有一个。</p>
<p>至此，剩下的任务就是筛 $10^{11}$ 以内的质数个数。我完全不会，但 clp012345 说有一种叫作 <a href="https://tanakarino.cn/2020/04/27/Meissel-Lehmer算法/" target="_blank" rel="noopener">Meissel-Lehmer</a> 的神棍算法可以 $O(n^\frac 23)$ 求这个东西，于是临时找了个板子复制粘贴过了（？）。赛后看官方题解居然是分段打表……</p>
<p>关于这个算法的更多内容可以看上面的链接。</p>
<h3 id="Code-By-Nanako"><a href="#Code-By-Nanako" class="headerlink" title="Code (By Nanako)"></a>Code (By Nanako)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(v) (v).begin(), (v).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unq(v) (v).erase(unique(all(v)), (v).end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ii int, int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> li int, int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll2 ll, ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vec vector</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pli pair <span class="meta-string">&lt;ll, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll2 pair <span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTI int T; cin &gt;&gt; T; while(T--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x) * (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test cerr &lt;&lt; <span class="meta-string">'!'</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main0</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">		freopen(<span class="string">"C:\\Users\\98497\\Desktop\\code\\file.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">clock_t</span> start, end;</span><br><span class="line">	<span class="comment">// start = clock();</span></span><br><span class="line">	main0();</span><br><span class="line">	<span class="comment">// end = clock();</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; (end - start) &lt;&lt; endl;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">		fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll INFF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span> + <span class="number">2</span>;<span class="comment">//通过知道前面的n^1/3的=质数可以推断后面n^2/3的质数所以可以适当减小</span></span><br><span class="line"><span class="keyword">bool</span> np[N];</span><br><span class="line"><span class="keyword">int</span> prime[N], pi[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getprime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    np[<span class="number">0</span>] = np[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    pi[<span class="number">0</span>] = pi[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) prime[++cnt] = i;</span><br><span class="line">        pi[i] = cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            np[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)   <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;<span class="comment">//为了减小内存可以不过是质数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">11</span> * <span class="number">13</span> * <span class="number">17</span>;<span class="comment">//为了减小内存可以不过要按质数减小如去掉17</span></span><br><span class="line"><span class="keyword">int</span> phi[PM + <span class="number">1</span>][M + <span class="number">1</span>], sz[M + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getprime();</span><br><span class="line">    sz[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= PM; ++i)  phi[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sz[i] = prime[i] * sz[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= PM; ++j) phi[j][i] = phi[j][i - <span class="number">1</span>] - phi[j / prime[i]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt2</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll r = (ll)<span class="built_in">sqrt</span>(x - <span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">while</span>(r * r &lt;= x)   ++r;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt3</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll r = (ll)cbrt(x - <span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">while</span>(r * r * r &lt;= x)   ++r;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getphi</span><span class="params">(ll x, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= M)  <span class="keyword">return</span> phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= prime[s]*prime[s])   <span class="keyword">return</span> pi[x] - s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= prime[s]*prime[s]*prime[s] &amp;&amp; x &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[sqrt2(x)];</span><br><span class="line">        ll ans = pi[x] - (s2x + s - <span class="number">2</span>) * (s2x - s + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt;= s2x; ++i) ans += pi[x / prime[i]];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getphi(x, s - <span class="number">1</span>) - getphi(x / prime[s], s - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getpi</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N)   <span class="keyword">return</span> pi[x];</span><br><span class="line">    ll ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pi[sqrt3(x)] + <span class="number">1</span>, ed = pi[sqrt2(x)]; i &lt;= ed; ++i) ans -= getpi(x / prime[i]) - i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lehmer_pi</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N)   <span class="keyword">return</span> pi[x];</span><br><span class="line">    <span class="keyword">int</span> a = (<span class="keyword">int</span>)lehmer_pi(sqrt2(sqrt2(x)));</span><br><span class="line">    <span class="keyword">int</span> b = (<span class="keyword">int</span>)lehmer_pi(sqrt2(x));</span><br><span class="line">    <span class="keyword">int</span> c = (<span class="keyword">int</span>)lehmer_pi(sqrt3(x));</span><br><span class="line">    ll sum = getphi(x, a) +(ll)(b + a - <span class="number">2</span>) * (b - a + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a + <span class="number">1</span>; i &lt;= b; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll w = x / prime[i];</span><br><span class="line">        sum -= lehmer_pi(w);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; c) <span class="keyword">continue</span>;</span><br><span class="line">        ll lim = lehmer_pi(sqrt2(w));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= lim; j++) sum -= lehmer_pi(w / prime[j]) - (j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main0</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	MULTI &#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; lehmer_pi(n) &lt;&lt; ' ' &lt;&lt; lehmer_pi(n / 2) &lt;&lt; endl;</span></span><br><span class="line">		ll k = lehmer_pi(n) - lehmer_pi(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; n - (n - k) / <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-B-Binomial"><a href="#Problem-B-Binomial" class="headerlink" title="Problem B. Binomial"></a>Problem B. Binomial</h2><p>大致题意：给定序列 $a_1,a_2,\dots, a_n$，问有多少对 $(a_i,a_j)$ $(1 \leq i,j \leq n)$ 满足 $\binom{a_i}{a_j} \bmod 2 = 1$ 。有 $z$ 组测试数据。</p>
<p>$1 \leq z \leq 10$</p>
<p>$1 \leq n \leq 10^6$, $1 \leq a_i \leq 10^6$</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>Lucas 定理有一个经典的推论：</p>
<script type="math/tex; mode=display">
\binom{a_i}{a_j} \bmod 2 = 1 \leftrightarrow a_i \& a_j = a_j</script><p>因此，问题转化为求</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n} \sum_{j=1}^{n} [a_i \& a_j = a_j]</script><p>记 $m = \lceil \log (\max a_i) \rceil$。显然，暴力枚举可以做到 $O(n^2)$ 的复杂度。优化一下，枚举子集可以做到 $O(3^m)$ 的复杂度。但是要通过这题还是不够。clp012345 说可以 <a href="https://codeforces.com/blog/entry/45223" target="_blank" rel="noopener">Sum over Submask DP</a> 做到 $O(m2^m)$，于是 triple_a 就现学现用写了一个。</p>
<p>这个算法本身就不讲了，可以看上面链接的文章。在国内，这个算法一般被称作快速莫比乌斯变换(FMT)或者子集和变换，英文不好的话也可以搜这两个词，但其实大部分文章都写得对新手不是很友好。个人觉得可以看<a href="http://blog.leanote.com/post/rockdu/TX20" target="_blank" rel="noopener">这篇</a>，我觉得下面这张插图真的把 FMT 解释得非常清楚。</p>
<p><img src="https://leanote.com/api/file/getImage?fileId=5bf20918ab64411b7b0012e2" alt="一个栗子"></p>
<h3 id="Code-By-triple-a"><a href="#Code-By-triple-a" class="headerlink" title="Code (By triple_a)"></a>Code (By triple_a)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],F[maxn],n,t;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span> (t--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);++i) b[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">cin</span>&gt;&gt;a[i], b[a[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">20</span>); ++i)</span><br><span class="line">			F[i] = b[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>; ++i) <span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span>&lt;&lt;<span class="number">20</span>); ++mask)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mask &amp; (<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">				F[mask] += F[mask^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);++i)&#123;</span><br><span class="line">			res+=b[i]*F[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是的，FMT 和 FWT 相关的题代码都不长，但是，确实不太好懂。</p>
<h2 id="Problem-C-Bookface"><a href="#Problem-C-Bookface" class="headerlink" title="Problem C. Bookface"></a>Problem C. Bookface</h2><p>大致题意：数轴上有 $n$ 个点 $a_1,a_2,\dots,a_n$，每次你可以花费 $1$ 代价使某个点向某个方向移动 $1$（但所有点必须时刻在正半轴上）。现在，希望你求出最小总代价，使得任意两点间的距离都大于等于 $d$。有 $z$ 组测试数据。</p>
<p>$1 \leq z \leq 10^5$</p>
<p>$1 \leq n \leq 2 \times 10^5$, $1 \leq d \leq 10^6$, $0 \leq a_i \leq 3 \times 10^{11}$</p>
<p>$\sum n \leq 10^6$</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>World Finalist 凹了两个小时都没出的题，鸽。</p>
<h2 id="Problem-D-Clique"><a href="#Problem-D-Clique" class="headerlink" title="Problem D. Clique"></a>Problem D. Clique</h2><p>没读，全场最不可做的题。</p>
<h2 id="Problem-E-Contamination"><a href="#Problem-E-Contamination" class="headerlink" title="Problem E. Contamination"></a>Problem E. Contamination</h2><p>triple_a 给我说的大致题意：平面上，给定 $n$ 个圆 $(c_x, c_y, r)$ 以及 $q$ 个询问 $(p_x,p_y,q_x,q_y,y_{min},y_{max})$，问能不能从 $(p_x,p_y) $ 走到 $(q_x,q_y)$，并满足路线不能碰到圆且任意时刻都有 $y \in [y_{min},y_{max}]$。</p>
<p>$1 \leq n, q \leq 10^6$</p>
<p>$-10^9 \leq c_x, c_y \leq 10^9$, $1 \leq r \leq 10^9$</p>
<p>$-10^9 \leq p_x,p_y,q_x,q_y,y_{min},y_{max} \leq 10^9$, $y_{min} \leq p_y, q_y \leq y_{max}$</p>
<p>一直到最后一个小时，我都是按这个题意理解的。我提出，如果圆两两不交，那么圆其实等价于其平行于 $y$ 轴的直径；但圆如果相交，就没有任何办法。最后一个小时 clp012345 来看 E，他自己读了一遍题，然后告诉我，题目里面说了圆是不交的……</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>但我不会维护这个东西，clp012345 说就是一棵离散化线段树。有空的时候再具体问他。</p>
<h3 id="Code-By-clp012345"><a href="#Code-By-clp012345" class="headerlink" title="Code (By clp012345)"></a>Code (By clp012345)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOE(i, s, t) for (int i = s; i &lt;= t; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, s, t) for (int i = s; i &lt; t; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 2300001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NINF -2002100100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, r;	</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">P p[K];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> cx[<span class="number">2</span> * K];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> sx, ymin, ymax, ex, id;	</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Q qu[K];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpY</span><span class="params">(P A, P B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.y &lt; B.y;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpQY</span><span class="params">(Q A, Q B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.ymin &lt; B.ymin;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> l[<span class="number">4</span> * K], r[<span class="number">4</span> * K];</span><br><span class="line">LL a[<span class="number">4</span> * K];</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> sol[K];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lb, <span class="keyword">int</span> rb)</span> </span>&#123;</span><br><span class="line">	a[u] = NINF;</span><br><span class="line">	<span class="keyword">if</span> (lb == rb) <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	build(l[u] = ++h, lb, (lb + rb) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	build(r[u] = ++h, (lb + rb) / <span class="number">2</span> + <span class="number">1</span>, rb); 	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lb, <span class="keyword">int</span> rb, <span class="keyword">int</span> pos, LL val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lb == rb) &#123;</span><br><span class="line">		a[u] = val; <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> mid = (lb + rb) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= pos) &#123;</span><br><span class="line">		insert(l[u], lb, mid, pos, val); </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		insert(r[u], mid + <span class="number">1</span>, rb, pos, val);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	a[u] = max(a[l[u]], a[r[u]]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lb, <span class="keyword">int</span> rb, <span class="keyword">int</span> lq, <span class="keyword">int</span> rq)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lq &lt;= lb &amp;&amp; rb &lt;= rq) &#123;</span><br><span class="line">		<span class="keyword">return</span> a[u];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (rb &lt; lq || rq &lt; lb) <span class="keyword">return</span> NINF;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> mid = (lb + rb) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	LL a1 = query(l[u], lb, mid, lq, rq);</span><br><span class="line">	LL a2 = query(r[u], mid + <span class="number">1</span>, rb, lq, rq);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> max(a1, a2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> tx[<span class="number">2</span> * K], head;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findX</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">1</span>, high = head;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (tx[mid] &lt;= val) &#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">			res = mid;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			high = mid - <span class="number">1</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;r);</span><br><span class="line">		p[i].x = x; p[i].y = y - r; p[i].r = r;	</span><br><span class="line">		cx[i] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">		<span class="keyword">int</span> px, py, qx, qy, ymin, ymax;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;px, &amp;py, &amp;qx, &amp;qy, &amp;ymin, &amp;ymax);</span><br><span class="line">	</span><br><span class="line">		cx[i + n] = px;</span><br><span class="line">		cx[i + n + q] = qx;</span><br><span class="line">		</span><br><span class="line">		qu[i].sx = min(px, qx);</span><br><span class="line">		qu[i].ex = max(px, qx);</span><br><span class="line">		qu[i].ymin = ymin;</span><br><span class="line">		qu[i].id = i;</span><br><span class="line">		qu[i].ymax = ymax;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmpY);</span><br><span class="line">	sort(qu + <span class="number">1</span>, qu + q + <span class="number">1</span>, cmpQY);</span><br><span class="line">	sort(cx + <span class="number">1</span>, cx + n + <span class="number">2</span> * q + <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> last;</span><br><span class="line">	FOE(i, <span class="number">1</span>, n + <span class="number">2</span> * q) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">1</span> || cx[i] != last) &#123;</span><br><span class="line">			head++; tx[head] = cx[i];</span><br><span class="line">			last = cx[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	build(<span class="number">0</span>, <span class="number">1</span>, head);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ptr = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">		<span class="keyword">int</span> cmin = qu[i].ymin;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//	printf("cmin is %d\n", cmin);</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (ptr &lt;= n &amp;&amp; p[ptr].y &lt;= cmin) &#123;</span><br><span class="line">			<span class="keyword">int</span> qx = findX(p[ptr].x);</span><br><span class="line">		<span class="comment">//	printf("INSERT %d\n", ptr);</span></span><br><span class="line">			insert(<span class="number">0</span>, <span class="number">1</span>, head, qx, p[ptr].y + p[ptr].r * <span class="number">2</span>);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//	printf("PTR is %d\n", ptr);</span></span><br><span class="line">			</span><br><span class="line">			ptr++;	</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> qsx = findX(qu[i].sx);</span><br><span class="line">		<span class="keyword">int</span> qex = findX(qu[i].ex);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//	printf("? %d %d\n", qsx, qex);</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> id = qu[i].id;</span><br><span class="line">		</span><br><span class="line">		sol[id] = (query(<span class="number">0</span>, <span class="number">1</span>, head, qsx, qex) &lt; qu[i].ymax);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, q) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sol[i]) <span class="built_in">puts</span>(<span class="string">"YES"</span>); <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-F-The-Halfwitters"><a href="#Problem-F-The-Halfwitters" class="headerlink" title="Problem F. The Halfwitters"></a>Problem F. The Halfwitters</h2><p>大致题意：给定长度 $n$，给定 $a, b, c$，给 $d$ 次询问。每次询问是一个长度为 $n$ 的排列，你可以对这个票列做三种操作：</p>
<ol>
<li><p>花费 $a$ 代价，交换相邻的两个数；</p>
</li>
<li><p>花费 $b$ 代价，翻转这个排列；</p>
</li>
<li><p>花费 $c$ 代价，shuffle 这个排列。</p>
</li>
</ol>
<p>对于每次询问，你需要求出，在最优的操作策略下，把排列排成升序所需的最小期望代价。有 $z$ 组测试数据。</p>
<p>$2 \leq n \leq 16$, $1 \leq a, b, c \leq 1000$, $1 \leq d \leq 10000$</p>
<p> $\sum d \leq 10^5$</p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>考虑只有第一种操作，我们不难发现，总代价只跟逆序对数 $inv$ 有关。</p>
<script type="math/tex; mode=display">
ans_{1}(inv) = inv \cdot a</script><p>考虑加上第二种操作，我们不难发现，先翻转一下再只进行以上操作可能会更快！</p>
<script type="math/tex; mode=display">
ans_{12}(inv) = \min(ans_{1}(inv), b + (\frac{n(n-1)}{2} - inv) \cdot a)</script><p>考虑加上第三种操作，我们不难发现，先 shuffle 一下再只进行以上操作可能会更快！我们令 shuffle 后代价的期望是 $x$。</p>
<script type="math/tex; mode=display">
ans_{123} = \min(ans_{12}(inv), x + c)</script><p>那么，怎么求 $x$ 呢？记逆序对数为 $inv$ 的排列有 $L_{inv}$ 个，如果我们只能进行一次 shuffle 操作，那么显然</p>
<script type="math/tex; mode=display">
x = \frac
{\sum_{inv = 0}^{\frac{n(n-1)}{2}} L_{inv} \cdot ans_{12}(inv)}
{n!}</script><p>但是实际上，有可能 shuffle 一次之后我们不满意，那就有可能继续 shuffle。所以我们只好列一个方程来计算 $x$。</p>
<p>我们知道，shuffle 后有一部分满意的情况（即 $ans_{12}(inv) \leq x + c$），其中每种情况的代价是 $ans_{12}(inv)$；也有一部分不满意的情况（即 $ans_{12}(inv) &gt; x + c$），其中每种情况的代价是 $x + c$。于是我们可以把上面那个错误的式子改成这样一个正确的式子：</p>
<script type="math/tex; mode=display">
x = \frac
{\sum_{ans_{12}(inv) \leq x + c} L_{inv} \cdot ans_{12}(inv) +
 \sum_{ans_{12}(inv) > x + c}    L_{inv} \cdot (x + c)         }
{n!}</script><p>为了方便计算这个东西，我们变换一下下标。令 $id$ 是一个排列且满足 $ans_{12}(id_i)$ 关于 $i$ 单增（用排序就可以实现），那么显然会有一个分界点 $k$ 使得</p>
<script type="math/tex; mode=display">
x = \frac
{\sum_{i = 0}^{k}                       L_{id_i} \cdot ans_{12}(id_i) +
 \sum_{i = k + 1}^{\frac{n(n-1)}{2}}    L_{id_i} \cdot (x + c)          }
{n!}</script><p>把 $x$ 挪到一边</p>
<script type="math/tex; mode=display">
x = \frac
{\sum_{i = 0}^{k}                       L_{id_i} \cdot ans_{12}(id_i) +
 \sum_{i = k + 1}^{\frac{n(n-1)}{2}}    L_{id_i} \cdot c          }
{n! - \sum_{i = k + 1}^{\frac{n(n-1)}{2}}    L_{id_i}}</script><p>考虑到 $n! = \sum_{i=0}^{\frac{n(n-1)}{2}} L_i$，我们可以修改得好看一点</p>
<script type="math/tex; mode=display">
x + c = \frac
{\sum_{i = 0}^{k} L_{id_i} \cdot ans_{12}(id_i) + n! \cdot c}
{\sum_{i = 0}^{k} L_{id_i}}</script><p>这个方程有两个未知量 $x$ 和 $k$，但是我们不难发现它们必定满足 $ans_{12}(k) \leq x + c \leq ans_{12}(k + 1)$。然后我们预处理一下前缀和，枚举 $k$ 找合法解就可以辣！</p>
<p>$L_i$ 不会求的话，可以参考 <a href="https://www.luogu.com.cn/problem/P2513" target="_blank" rel="noopener">[HAOI2009] 逆序对数列 </a>。</p>
<h3 id="Code-By-Nanako-1"><a href="#Code-By-Nanako-1" class="headerlink" title="Code (By Nanako)"></a>Code (By Nanako)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(v) (v).begin(), (v).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unq(v) (v).erase(unique(all(v)), (v).end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ii int, int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> li int, int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll2 ll, ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vec vector</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pli pair <span class="meta-string">&lt;ll, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll2 pair <span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTI int T; cin &gt;&gt; T; while(T--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x) * (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test cerr &lt;&lt; <span class="meta-string">'!'</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main0</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">		freopen(<span class="string">"C:\\Users\\98497\\Desktop\\code\\file.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">clock_t</span> start, end;</span><br><span class="line">	<span class="comment">// start = clock();</span></span><br><span class="line">	main0();</span><br><span class="line">	<span class="comment">// end = clock();</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; (end - start) &lt;&lt; endl;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">		fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll INFF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line">ll L[N][M];</span><br><span class="line">ll fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	L[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">16</span>;++i) &#123;</span><br><span class="line">		ll pre = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">120</span>;++j) &#123;</span><br><span class="line">			pre += L[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (j - i &gt;= <span class="number">0</span>) pre -= L[i - <span class="number">1</span>][j - i];</span><br><span class="line">			L[i][j] = pre;</span><br><span class="line">			<span class="comment">//cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ':' &lt;&lt; f[i][j] &lt;&lt; endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">16</span>;++i) &#123;</span><br><span class="line">		fac[i] = fac[i - <span class="number">1</span>] * i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll v[N];</span><br><span class="line">ll t[M], id[M];</span><br><span class="line">ll pre1[M], pre2[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t[x] &lt; t[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span> <span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main0</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	MULTI &#123;</span><br><span class="line">		ll n, a, b, c, d;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">		ll lim = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= lim;++i) &#123;</span><br><span class="line">			t[i] = min(i * a, b + (lim - i) * a);</span><br><span class="line">			id[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(id, id + lim + <span class="number">1</span>, cmp);</span><br><span class="line">		</span><br><span class="line">		pre1[<span class="number">0</span>] = L[n][<span class="number">0</span>];</span><br><span class="line">		pre2[<span class="number">0</span>] = L[n][<span class="number">0</span>] * t[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= lim;++i) &#123;</span><br><span class="line">			pre1[i] = pre1[i - <span class="number">1</span>] + L[n][id[i]];</span><br><span class="line">			pre2[i] = pre2[i - <span class="number">1</span>] + L[n][id[i]] * t[id[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ll k, p, q;</span><br><span class="line">		<span class="keyword">double</span> x;</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>;k &lt; lim;++k) &#123;</span><br><span class="line">			p = pre2[k] + c * fac[n];</span><br><span class="line">			q = pre1[k];</span><br><span class="line">			ll gcdd = gcd(p, q);</span><br><span class="line">			p /= gcdd;</span><br><span class="line">			q /= gcdd;</span><br><span class="line">			x = <span class="number">1.0</span> * p / q;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;k&lt;&lt;':'&lt;&lt;p&lt;&lt;'/'&lt;&lt;q&lt;&lt;'='&lt;&lt;x&lt;&lt;' '&lt;&lt;t[id[k]]&lt;&lt;'~'&lt;&lt;t[id[k+1]]&lt;&lt; endl;</span></span><br><span class="line">			<span class="keyword">if</span> ((t[id[k]] &lt;= x) &amp;&amp; (x &lt;= t[id[k+<span class="number">1</span>]])) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> cur = <span class="number">1</span>;cur &lt;= d;++cur) &#123;</span><br><span class="line">			<span class="keyword">int</span> inv = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i - <span class="number">1</span>;++j) &#123;</span><br><span class="line">					inv += (v[j] &gt; v[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (t[inv] &lt;= x) <span class="built_in">cout</span> &lt;&lt; t[inv] &lt;&lt; <span class="string">'/'</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">'/'</span> &lt;&lt; q &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-G-Invited-Speakers"><a href="#Problem-G-Invited-Speakers" class="headerlink" title="Problem G. Invited Speakers"></a>Problem G. Invited Speakers</h2><p>大致题意：给定 $2n$ 个不同的点 $(x_i,y_i)$，$A$ 类型和 $B$ 类型各 $n$ 个，保证不存在三点共线。希望你能给出一种方案把它们配对成 $n$ 对 $AB$，并且每对 $AB$ 之间用折线（$[1, 100]$ 条首尾相连的线段）相连，折线之间两两不交。有 $z$ 组测试数据。</p>
<p>$1 \leq z \leq 200$</p>
<p>$1 \leq n \leq 6$</p>
<p>$0 \leq |x_i|,|y_i| \leq 100$</p>
<h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>我读的题，第一反应是：就这？</p>
<p>还害我确认了好几遍题意和数据范围。</p>
<p><del>精通脚撕 FFT 的各种姿势的</del>队友 Luowaterbi 曾经告诉我，没有三点共线的时候，两种一样多的点必然存在一种配对方案使得每对之间只用一条线段相连并且所有线段都不交。既然这题数据范围这么小，直接大力枚举配对方案，再大力枚举判断是否存在两线段交就行了。时间复杂度 $O(n!n^2)$。</p>
<p>由于我计算几何过于垃圾不想写，我就交给 triple_a 写了。triple_a 写得也很有意思，没用到计算几何的线段交判定，直接 $O(n!n)$ 取所有线段长度之和最小的方案，而这其实就是所有线段都不交的那个方案。</p>
<p>官方题解是个构造，懒得看具体折线怎么画了，反正意义不大，出题人可能是没想到有结论。</p>
<h3 id="Code-By-triple-a-1"><a href="#Code-By-triple-a-1" class="headerlink" title="Code (By triple_a)"></a>Code (By triple_a)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">7</span>],res[<span class="number">7</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a[<span class="number">7</span>],b[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">double</span> dist;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i].first&gt;&gt;a[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;b[i].first&gt;&gt;b[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        dist=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            p[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> f=[&amp;](pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;u, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; v)&#123;</span><br><span class="line">            <span class="keyword">return</span> (u.first-v.first)*(u.first-v.first)+(u.second-v.second)*(u.second-v.second);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                sum+=<span class="built_in">sqrt</span>(f(a[i],b[p[i]]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum&lt;dist)&#123;</span><br><span class="line">                dist=sum;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                    res[i]=p[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(p,p+n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;a[i].first&lt;&lt;<span class="string">" "</span>&lt;&lt;a[i].second&lt;&lt;<span class="string">" "</span>&lt;&lt;b[res[i]].first&lt;&lt;<span class="string">" "</span>&lt;&lt;b[res[i]].second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-H-Lighthouses"><a href="#Problem-H-Lighthouses" class="headerlink" title="Problem H. Lighthouses"></a>Problem H. Lighthouses</h2><p>大致题意：给一个有 $n$ 个顶点的凸多边形，其顶点用 $(x_i,y_i)$ 表示。以 $n$ 个顶点为结点，给定 $m$ 条边 $(u_i,v_i)$。希望求出图上最长的（指欧几里得距离）且不和自己相交的（几何意义上）路的长度。有 $z$ 组测试数据。</p>
<p>$3 \leq n \leq 300$, $0 \leq m \leq \frac{n(n-1)}{2}$, $1 \leq u_i \neq v_i \leq n$</p>
<p>$-10^9 \leq x_i, y_i \leq 10^9$</p>
<p>$\sum n \leq 3000$</p>
<h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>这题赛中我读都没读就被 clp012345 切了，赛后才看。</p>
<p>经过观察我们发现其实合法的路只能是在环上往一个方向转，那么我们上一个区间 DP 就可以了。开三个维度，分别表示起点、终点、顺/逆时针，状态转移 $O(n)$ 枚举。时间复杂度 $O(n^3)$。</p>
<p>区间 DP 要上环的话，通常做法就是开两倍数组复制一遍吧，参考石子合并。</p>
<h3 id="Code-By-clp012345-1"><a href="#Code-By-clp012345-1" class="headerlink" title="Code (By clp012345)"></a>Code (By clp012345)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOE(i, s, t) for (int i = s; i &lt;= t; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, s, t) for (int i = s; i &lt; t; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 601</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x[K], y[K];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> id1, <span class="keyword">int</span> id2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> dx = <span class="built_in">abs</span>(x[id1] - x[id2]);</span><br><span class="line">	<span class="keyword">double</span> dy = <span class="built_in">abs</span>(y[id1] - y[id2]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ok[K][K][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">double</span> dp[K][K][<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> has[K][K];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prev</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (u == <span class="number">1</span> ? n : u - <span class="number">1</span>);	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (u == n ? <span class="number">1</span> : u + <span class="number">1</span>);	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> sta, <span class="keyword">int</span> fin, <span class="keyword">int</span> dir)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sta == fin) <span class="keyword">return</span> <span class="number">0.00</span>;</span><br><span class="line">	<span class="keyword">if</span> (ok[sta][fin][dir] == <span class="number">0</span>) &#123;</span><br><span class="line">		dp[sta][fin][dir] = <span class="number">0.00</span>;</span><br><span class="line">		ok[sta][fin][dir] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (dir == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// clockwise</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = nxt(sta); i != fin; i = nxt(i)) &#123;</span><br><span class="line">			<span class="comment">//	printf("sta %d fin %d i %d %d\n", sta, fin, i, has[sta][i]);</span></span><br><span class="line">				<span class="keyword">if</span> (has[sta][i]) &#123;</span><br><span class="line">					dp[sta][fin][dir] = max(dp[sta][fin][dir], max(solve2(i, fin, <span class="number">1</span>), solve2(i, sta, <span class="number">0</span>)) + dist(sta, i));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// anti clockwise</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = prev(sta); i != fin; i = prev(i)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (has[sta][i]) &#123;</span><br><span class="line">					dp[sta][fin][dir] = max(dp[sta][fin][dir], max(solve2(i, fin, <span class="number">0</span>), solve2(i, sta, <span class="number">1</span>)) + dist(sta, i));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dp[sta][fin][dir];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, n) FOE(j, <span class="number">1</span>, n) ok[i][j][<span class="number">0</span>] = ok[i][j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> ret = <span class="number">0.00</span>;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, n) FOE(j, <span class="number">1</span>, n) has[i][j] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		has[u][v] = has[v][u] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, n) FOE(j, <span class="number">1</span>, n) <span class="keyword">if</span> (has[i][j]) &#123;</span><br><span class="line">		<span class="keyword">double</span> temp = max(solve2(j, i, <span class="number">1</span>), solve2(j, i, <span class="number">0</span>)) + dist(i, j);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (temp &gt; ret) ret = temp;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.9f\n"</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-I-Sum-of-Palindromes"><a href="#Problem-I-Sum-of-Palindromes" class="headerlink" title="Problem I. Sum of Palindromes"></a>Problem I. Sum of Palindromes</h2><p>大致题意：把给定的 $n$ 位数分解成不超过 $25$ 个回文数（不允许前导零）。有 $z$ 组测试数据。</p>
<p>$1 \leq z \leq 20000$</p>
<p>$1 \leq n \leq 10^5$</p>
<p>$\sum n \leq 3 \times 10^6$</p>
<h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>跟国内比赛撞车了（2016 CCPC Changchun J），可能这些毛子出题人没怎么看国内比赛的题。</p>
<p>做法很简单，就是每次减掉小于当前数的最大的回文数。很显然每次可以减掉一半的长度，所以大概只需要 $\log n$ 次就够了。唯一的难点在于实现有点恶心，需要上高精度，不过我直接复制以前打 16 长春时候的代码了。（那个时候写得很丑不要骂我呜呜呜）</p>
<h3 id="Code-By-Nanako-2"><a href="#Code-By-Nanako-2" class="headerlink" title="Code (By Nanako)"></a>Code (By Nanako)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">55</span>][N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> it = <span class="number">1</span>;it &lt;= T;it++) &#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;s);</span><br><span class="line">		a[<span class="number">0</span>] = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a[<span class="number">0</span>];i++) &#123;</span><br><span class="line">			a[a[<span class="number">0</span>] - i] = s[i] - <span class="number">48</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (a[a[<span class="number">0</span>]] == <span class="number">0</span>) a[<span class="number">0</span>]--;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (a[<span class="number">0</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (a[<span class="number">2</span>] == <span class="number">1</span>) &amp;&amp; (a[<span class="number">1</span>] == <span class="number">0</span>)) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= a[<span class="number">0</span>];i++) b[i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = a[<span class="number">0</span>];i &gt;= (a[<span class="number">0</span>] + <span class="number">1</span>) / <span class="number">2</span>;i--) &#123;</span><br><span class="line">				b[i] = a[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> p = (a[<span class="number">0</span>] &amp; <span class="number">1</span>) ? (a[<span class="number">0</span>] + <span class="number">1</span>) / <span class="number">2</span> : a[<span class="number">0</span>] / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			b[p]--;</span><br><span class="line">			<span class="keyword">while</span> (b[p] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				b[p] += <span class="number">10</span>;</span><br><span class="line">				b[++p]--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//for (int i = a[0];i &gt;= 1;i--) cout &lt;&lt; b[i];cout &lt;&lt; " b" &lt;&lt; endl;</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= a[<span class="number">0</span>];i++) c[i] = <span class="number">0</span>;</span><br><span class="line">			c[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = a[<span class="number">0</span>];i &gt;= (a[<span class="number">0</span>] + <span class="number">1</span>) / <span class="number">2</span>;i--) &#123;</span><br><span class="line">				c[i] = b[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= (a[<span class="number">0</span>] + <span class="number">1</span>) / <span class="number">2</span>;i++) &#123;</span><br><span class="line">				c[i] = b[a[<span class="number">0</span>] - i + <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (b[a[<span class="number">0</span>]] == <span class="number">0</span>) c[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">			<span class="keyword">while</span> (c[c[<span class="number">0</span>]] == <span class="number">0</span>) c[<span class="number">0</span>]--;</span><br><span class="line">			<span class="comment">//for (int i = a[0];i &gt;= 1;i--) cout &lt;&lt; c[i];cout &lt;&lt; " c" &lt;&lt; endl;</span></span><br><span class="line">			</span><br><span class="line">			ans[++cnt][<span class="number">0</span>] = c[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= c[<span class="number">0</span>];i++) &#123;</span><br><span class="line">				ans[cnt][i] = c[i];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= a[<span class="number">0</span>];i++) &#123;</span><br><span class="line">				a[i] -= c[i];</span><br><span class="line">				<span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					a[i + <span class="number">1</span>]--;</span><br><span class="line">					a[i] += <span class="number">10</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (a[a[<span class="number">0</span>]] == <span class="number">0</span>) a[<span class="number">0</span>]--;</span><br><span class="line">			<span class="comment">//for (int i = a[0];i &gt;= 1;i--) cout &lt;&lt; a[i];cout &lt;&lt; a[0] &lt;&lt; " a" &lt;&lt; endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">			ans[++cnt][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			ans[cnt][<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">			ans[++cnt][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			ans[cnt][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">			ans[++cnt][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			ans[cnt][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = ans[i][<span class="number">0</span>];j &gt;= <span class="number">1</span>;j--) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-J-Space-Gophers"><a href="#Problem-J-Space-Gophers" class="headerlink" title="Problem J. Space Gophers"></a>Problem J. Space Gophers</h2><p>大致题意：有一个由边长为 $1$ 的小正方体组成的边长为 $10^6$ 的实心正方体。在其中挖 $n$ 条隧道，每条隧道用 $(-,y_i,z_i)$ 或 $(x_i,-,z_i)$ 或 $(x_i,y_i,-)$ 表示。挖隧道的含义是，指定其中两个维度的坐标，沿平行于另一个维度轴线的方向把 $10^6$ 个方块拿走。挖完 $n$ 条隧道之后，$q$ 次询问两个点 $(s_x,s_y,s_z)$ 和 $(t_x,t_y,t_z)$ 是否可以通过若干条隧道连通。保证 $s$ 和 $t$ 处于隧道中。有 $z$ 组测试数据。</p>
<p>$1 \leq z \leq 6$</p>
<p>$1 \leq n \leq 3 \times 10^5$, $1 \leq x_i,y_i,z_i \leq 10^6$</p>
<p>$1 \leq q \leq 5 \times 10^5$, $1 \leq s_x,s_y,s_z,t_x,t_y,t_z \leq 10^6$</p>
<h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>clp 单切之前大致跟我讲了一下做法。实际上两条隧道连通 iff 某一个维度坐标相等或相差 1，于是我们要做的事情就是把所有这样的隧道对找出来，在并查集上 merge 起来。</p>
<p>这个东西说起来简单，实现起来就比较呕吐……具体还是看代码吧……</p>
<p>merge 的时候注意并查集上类似于网络流中超级源点的思想的运用，平方枚举 merge 肯定过不了。</p>
<h3 id="Code-By-clp012345-2"><a href="#Code-By-clp012345-2" class="headerlink" title="Code (By clp012345)"></a>Code (By clp012345)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOE(i, s, t) for (int i = s; i &lt;= t; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, s, t) for (int i = s; i &lt; t; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 5000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> nxt[K], sz[K];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">par</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (nxt[u] == u ? u : nxt[u] = par(nxt[u]));	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s1 = par(u);</span><br><span class="line">	<span class="keyword">int</span> s2 = par(v);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (sz[s1] &gt; sz[s2]) swap(s1, s2);</span><br><span class="line">	</span><br><span class="line">	nxt[s1] = s2;</span><br><span class="line">	sz[s2] += sz[s1];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x[D + <span class="number">100</span>], y[D + <span class="number">100</span>], z[D + <span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> goodX[D], goodY[D], goodZ[D];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;, <span class="keyword">int</span> &gt; M;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> px[D], py[D], pz[D];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	printf("seek %d %d %d ? %d %d %d \n", x, y, z, M[mp(mp(x, y), -1)], M[mp(mp(x, -1), z)], M[mp(mp(-1, y), z)]);</span></span><br><span class="line">	<span class="keyword">int</span> a1 = M[mp(mp(x, y), <span class="number">-1</span>)];</span><br><span class="line">	<span class="keyword">if</span> (a1) <span class="keyword">return</span> a1;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a2 = M[mp(mp(x, <span class="number">-1</span>), z)];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (a2) <span class="keyword">return</span> a2;</span><br><span class="line">	<span class="keyword">return</span> M[mp(mp(<span class="number">-1</span>, y), z)];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"> </span><br><span class="line">	M.clear();	</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, D) &#123;</span><br><span class="line">		x[i].clear(); y[i].clear(); z[i].clear();	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;px[i], &amp;py[i], &amp;pz[i]);</span><br><span class="line">		</span><br><span class="line">		M[mp(mp(px[i], py[i]), pz[i])] = i;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (px[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">			x[px[i]].pb(i);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (py[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">			y[py[i]].pb(i);	</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (pz[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">			z[pz[i]].pb(i);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, n + <span class="number">3</span> * D) &#123;</span><br><span class="line">		nxt[i] = i;</span><br><span class="line">		sz[i] = <span class="number">1</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pz[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">0</span>; dx &lt;= <span class="number">1</span>; dx++) <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">0</span>; dy &lt;= <span class="number">1</span>; dy++) <span class="keyword">if</span> (<span class="built_in">abs</span>(dx) + <span class="built_in">abs</span>(dy) == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> id2 = M[mp(mp(px[i] + dx, py[i] + dy), <span class="number">-1</span>)];</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (id2) merge(id2, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (py[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">0</span>; dx &lt;= <span class="number">1</span>; dx++) <span class="keyword">for</span> (<span class="keyword">int</span> dz = <span class="number">0</span>; dz &lt;= <span class="number">1</span>; dz++) <span class="keyword">if</span> (<span class="built_in">abs</span>(dx) + <span class="built_in">abs</span>(dz) == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> id2 = M[mp(mp(px[i] + dx, <span class="number">-1</span>), pz[i] + dz)];</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (id2) merge(id2, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (px[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">0</span>; dy &lt;= <span class="number">1</span>; dy++) <span class="keyword">for</span> (<span class="keyword">int</span> dz = <span class="number">0</span>; dz &lt;= <span class="number">1</span>; dz++) <span class="keyword">if</span> (<span class="built_in">abs</span>(dy) + <span class="built_in">abs</span>(dz) == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> id2 = M[mp(mp(<span class="number">-1</span>, py[i] + dy), pz[i] + dz)];</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (id2) merge(id2, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, D) &#123;</span><br><span class="line">		<span class="keyword">int</span> g1 = <span class="number">0</span>, g2 = <span class="number">0</span>;</span><br><span class="line">		FOR(j, <span class="number">0</span>, x[i].size()) &#123;</span><br><span class="line">			<span class="keyword">int</span> id = x[i][j];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (py[id] == <span class="number">-1</span>) g1 = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (pz[id] == <span class="number">-1</span>) g2 = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		goodX[i] = g1 * <span class="number">2</span> + g2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOR(i, <span class="number">1</span>, D) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((goodX[i] | goodX[i + <span class="number">1</span>]) == <span class="number">3</span>) &#123;</span><br><span class="line">			FOR(j, <span class="number">0</span>, x[i].size()) merge(i + n, x[i][j]);</span><br><span class="line">			FOR(j, <span class="number">0</span>, x[i + <span class="number">1</span>].size()) merge(i + n, x[i + <span class="number">1</span>][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, D) &#123;</span><br><span class="line">		<span class="keyword">int</span> g1 = <span class="number">0</span>, g2 = <span class="number">0</span>;</span><br><span class="line">		FOR(j, <span class="number">0</span>, y[i].size()) &#123;</span><br><span class="line">			<span class="keyword">int</span> id = y[i][j];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (px[id] == <span class="number">-1</span>) g1 = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (pz[id] == <span class="number">-1</span>) g2 = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		goodY[i] = g1 * <span class="number">2</span> + g2;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	FOR(i, <span class="number">1</span>, D) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((goodY[i] | goodY[i + <span class="number">1</span>]) == <span class="number">3</span>) &#123;</span><br><span class="line">			FOR(j, <span class="number">0</span>, y[i].size()) merge(i + D + n, y[i][j]);</span><br><span class="line">			FOR(j, <span class="number">0</span>, y[i + <span class="number">1</span>].size()) merge(i + D + n, y[i + <span class="number">1</span>][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOE(i, <span class="number">1</span>, D) &#123;</span><br><span class="line">		<span class="keyword">int</span> g1 = <span class="number">0</span>, g2 = <span class="number">0</span>;</span><br><span class="line">		FOR(j, <span class="number">0</span>, z[i].size()) &#123;</span><br><span class="line">			<span class="keyword">int</span> id = z[i][j];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (px[id] == <span class="number">-1</span>) g1 = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (py[id] == <span class="number">-1</span>) g2 = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		goodZ[i] = g1 * <span class="number">2</span> + g2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FOR(i, <span class="number">1</span>, D) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((goodZ[i] | goodZ[i + <span class="number">1</span>]) == <span class="number">3</span>) &#123;</span><br><span class="line">			FOR(j, <span class="number">0</span>, z[i].size()) merge(i + <span class="number">2</span> * D + n, z[i][j]);</span><br><span class="line">			FOR(j, <span class="number">0</span>, z[i + <span class="number">1</span>].size()) merge(i + <span class="number">2</span> * D + n, z[i + <span class="number">1</span>][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a1, a2, a3, a4, a5, a6;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;a1, &amp;a2, &amp;a3, &amp;a4, &amp;a5, &amp;a6);</span><br><span class="line">		<span class="keyword">int</span> id1 = seek(a1, a2, a3);</span><br><span class="line">		<span class="keyword">int</span> id2 = seek(a4, a5, a6);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//	printf("conv %d %d\n", id1, id2);</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (par(id1) == par(id2)) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"YES"</span>);	</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"NO"</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-K-To-argue-or-not-to-argue"><a href="#Problem-K-To-argue-or-not-to-argue" class="headerlink" title="Problem K. To argue, or not to argue"></a>Problem K. To argue, or not to argue</h2><p>大致题意：一个 $n \times m$ 的网格，某些位置是可用的（可以坐一个人），某些位置是不可用的（不能坐人）。现在有 $k$ 对共 $2k$ 个人，所有人两两不同。每个人都要坐到一个可用的位置，且每一对人坐的两个位置都不能相邻。问安排座位的方案数对 $10^9+7$ 取余后的结果。有 $z$ 组测试数据，数据保证可用的座位至少有 $2k$ 个。</p>
<p>$1 \leq z \leq 10$</p>
<p>$1 \leq n, m \leq 144$, $1 \leq k \leq \frac{nm}{2}$</p>
<h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><p>我读的题，第一反应是反过来统计有相邻的情况的方案数然后做个容斥。跟 clp012345 说了下题意，他说要再上个插头 DP。</p>
<p>事实证明这两个思路都是对的，但具体实现实在是太过复杂，我们在有更简单的题没写完的情况下也就放弃了，没继续往下讨论。</p>
<h2 id="Problem-L-Wizards-Unite"><a href="#Problem-L-Wizards-Unite" class="headerlink" title="Problem L. Wizards Unite"></a>Problem L. Wizards Unite</h2><p>大致题意：给 $1$ 把金钥匙（可多次使用的钥匙），$k$ 把银钥匙（只能用一次）。给 $n$ 个箱子，每个箱子有一个打开所需时间 $t_i$（跟钥匙类型无关）。一把钥匙同时只能开一个箱子，问打开所有箱子所需的最小总时间。有 $z$ 组测试数据。</p>
<p>$0 \leq k &lt; n \leq 10^5$</p>
<p>$0 \leq t_i \leq 10^9$</p>
<p>$\sum n \leq 10^6$</p>
<h3 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h3><p>本场最简单的题。</p>
<p>不失一般性，我们认为所有箱子按 $t_i$ 排升序。显然方案只能是 $k$ 把银钥匙都用来开一个箱子，金钥匙开其他所有箱子，而答案就是以下两者中的较大值：用银钥匙的箱子中耗时最长的一个的耗时；金钥匙开其他所有箱子的耗时之和。</p>
<p>注意到答案无论如何也不可能小于 $t_n$，也就是说用银钥匙开 $t_n$ 箱子一定不会浪费时间。那么为了令金钥匙耗时之和尽可能小，实际上 $k$ 把银钥匙开的就是最右边的 $k$ 个箱子，于是答案就很显然了。时间复杂度 $O(n \log n)$。</p>
<p>我读的，读完第一反应居然是二分答案找一个分界点使得银钥匙开的是这个分界点左边的 $k$ 个……要说的话虽然更慢（我写的是 $O(n \log^2 n)$……）但是结果也是对的，但我一个大于写成了大于等于交了一发 WA……签到题都 WA，很惭愧……</p>
<p>下面的代码还是赛中交的二分答案版本，反正正解上面说的很清楚了，也很简单，懒得再写了。</p>
<h3 id="Code-By-Nanako-3"><a href="#Code-By-Nanako-3" class="headerlink" title="Code (By Nanako)"></a>Code (By Nanako)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(v) (v).begin(), (v).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unq(v) (v).erase(unique(all(v)), (v).end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ii int, int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> li int, int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll2 ll, ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vec vector</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pli pair <span class="meta-string">&lt;ll, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll2 pair <span class="meta-string">&lt;ll, ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTI int T; cin &gt;&gt; T; while(T--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x) * (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test cerr &lt;&lt; <span class="meta-string">'!'</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main0</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">		freopen(<span class="string">"C:\\Users\\98497\\Desktop\\code\\file.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">clock_t</span> start, end;</span><br><span class="line">	<span class="comment">// start = clock();</span></span><br><span class="line">	main0();</span><br><span class="line">	<span class="comment">// end = clock();</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; (end - start) &lt;&lt; endl;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">		fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll INFF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"> </span><br><span class="line">ll a[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main0</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	MULTI &#123;</span><br><span class="line">		<span class="keyword">int</span> n, k;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		ll sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">			sum += a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		ll l = <span class="number">0</span>, r = sum;</span><br><span class="line">		<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">			ll mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">int</span> pos = upper_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, mid) - a; pos--;</span><br><span class="line">			ll silver = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = max(<span class="number">1</span>, pos - k + <span class="number">1</span>);i &lt;= pos;++i) silver += a[i];</span><br><span class="line">			<span class="comment">//cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; mid &lt;&lt; ':' &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; silver &lt;&lt; endl;</span></span><br><span class="line">			<span class="keyword">if</span> (sum - silver &gt; mid) l = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
        <category>训练赛</category>
      </categories>
  </entry>
</search>
